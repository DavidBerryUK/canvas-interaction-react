import React, { useRef, useEffect, useState } from 'react';

const regions = {
	1: { x: 100, y: 100, width: 200, height: 150 },
	2: { x: 500, y: 200, width: 250, height: 200 },
	3: { x: 300, y: 500, width: 300, height: 180 },
	4: { x: 800, y: 400, width: 200, height: 200 },
};

export default function CanvasViewer() {
	const canvasRef = useRef<HTMLCanvasElement | null>(null);
	const [scale, setScale] = useState(1);
	const [offsetX, setOffsetX] = useState(0);
	const [offsetY, setOffsetY] = useState(0);

	const [isPanning, setIsPanning] = useState(false);
	const [lastX, setLastX] = useState(0);
	const [lastY, setLastY] = useState(0);

	const [targetScale, setTargetScale] = useState(1);
	const [targetOffsetX, setTargetOffsetX] = useState(0);
	const [targetOffsetY, setTargetOffsetY] = useState(0);

	// --- Resize handling ---
	useEffect(() => {
		const canvas = canvasRef.current!;
		const resize = () => {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		};
		resize();
		window.addEventListener('resize', resize);
		return () => window.removeEventListener('resize', resize);
	}, []);

	// --- Drawing ---
	useEffect(() => {
		const canvas = canvasRef.current!;
		const ctx = canvas.getContext('2d')!;

		const draw = () => {
			// Smooth transition
			const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
			setScale((s) => lerp(s, targetScale, 0.1));
			setOffsetX((x) => lerp(x, targetOffsetX, 0.1));
			setOffsetY((y) => lerp(y, targetOffsetY, 0.1));

			ctx.clearRect(0, 0, canvas.width, canvas.height);

			ctx.save();
			ctx.translate(offsetX, offsetY);
			ctx.scale(scale, scale);

			// Draw background grid
			ctx.strokeStyle = '#ddd';
			for (let x = 0; x < 2000; x += 50) {
				ctx.beginPath();
				ctx.moveTo(x, 0);
				ctx.lineTo(x, 2000);
				ctx.stroke();
			}
			for (let y = 0; y < 2000; y += 50) {
				ctx.beginPath();
				ctx.moveTo(0, y);
				ctx.lineTo(2000, y);
				ctx.stroke();
			}

			// Draw regions
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 2 / scale;
			Object.entries(regions).forEach(([key, r]) => {
				ctx.strokeRect(r.x, r.y, r.width, r.height);
				ctx.fillStyle = 'red';
				ctx.font = `${14 / scale}px sans-serif`;
				ctx.fillText(key, r.x + 5 / scale, r.y + 15 / scale);
			});

			ctx.restore();

			// --- Instructions overlay (not affected by zoom/pan) ---
			ctx.fillStyle = 'rgba(0,0,0,0.6)';
			ctx.fillRect(10, 10, 280, 160);
			ctx.fillStyle = 'white';
			ctx.font = '14px sans-serif';
			ctx.textBaseline = 'top';
			const instructions = [
				'Controls:',
				'ðŸ–±ï¸ Drag: Pan',
				'ðŸ–±ï¸ Wheel: Zoom at cursor',
				'âŒ¨ï¸ +/-: Zoom in/out',
				'âŒ¨ï¸ 0: Reset view',
				'âŒ¨ï¸ 1-4: Zoom to region',
				'ðŸ“± Pinch: Zoom on mobile',
				'ðŸ“± Drag: Pan on mobile',
			];
			instructions.forEach((line, i) => {
				ctx.fillText(line, 20, 20 + i * 18);
			});

			requestAnimationFrame(draw);
		};

		draw();
	}, [scale, offsetX, offsetY, targetScale, targetOffsetX, targetOffsetY]);

	// --- Mouse Events ---
	const handleMouseDown = (e: React.MouseEvent) => {
		setIsPanning(true);
		setLastX(e.clientX);
		setLastY(e.clientY);
	};
	const handleMouseUp = () => setIsPanning(false);
	const handleMouseMove = (e: React.MouseEvent) => {
		if (!isPanning) return;
		const dx = e.clientX - lastX;
		const dy = e.clientY - lastY;
		setLastX(e.clientX);
		setLastY(e.clientY);
		setTargetOffsetX((x) => x + dx);
		setTargetOffsetY((y) => y + dy);
	};

	// --- Wheel zoom at cursor ---
	const handleWheel = (e: React.WheelEvent) => {
		e.preventDefault();
		const rect = canvasRef.current!.getBoundingClientRect();
		const cursorX = e.clientX - rect.left;
		const cursorY = e.clientY - rect.top;

		const worldX = (cursorX - targetOffsetX) / targetScale;
		const worldY = (cursorY - targetOffsetY) / targetScale;

		const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
		const newScale = Math.min(Math.max(targetScale * zoomFactor, 0.1), 10);

		const newOffsetX = cursorX - worldX * newScale;
		const newOffsetY = cursorY - worldY * newScale;

		setTargetScale(newScale);
		setTargetOffsetX(newOffsetX);
		setTargetOffsetY(newOffsetY);
	};

	// --- Keyboard shortcuts ---
	useEffect(() => {
		const handleKey = (e: KeyboardEvent) => {
			if (e.key === '+' || e.key === '=') {
				setTargetScale((s) => Math.min(s * 1.2, 10));
			} else if (e.key === '-') {
				setTargetScale((s) => Math.max(s * 0.8, 0.1));
			} else if (e.key === '0') {
				setTargetScale(1);
				setTargetOffsetX(0);
				setTargetOffsetY(0);
			} else if (['1', '2', '3', '4'].includes(e.key)) {
				const r = regions[e.key as keyof typeof regions];
				const canvas = canvasRef.current!;
				const margin = 40;
				const scaleX = (canvas.width - margin * 2) / r.width;
				const scaleY = (canvas.height - margin * 2) / r.height;
				const newScale = Math.min(scaleX, scaleY);
				const newOffsetX = margin + (canvas.width - margin * 2 - r.width * newScale) / 2 - r.x * newScale;
				const newOffsetY = margin + (canvas.height - margin * 2 - r.height * newScale) / 2 - r.y * newScale;
				setTargetScale(newScale);
				setTargetOffsetX(newOffsetX);
				setTargetOffsetY(newOffsetY);
			}
		};
		window.addEventListener('keydown', handleKey);
		return () => window.removeEventListener('keydown', handleKey);
	}, []);

	return (
		<canvas
			ref={canvasRef}
			style={{ display: 'block', width: '100vw', height: '100vh', background: 'white' }}
			onMouseDown={handleMouseDown}
			onMouseUp={handleMouseUp}
			onMouseMove={handleMouseMove}
			onWheel={handleWheel}
		/>
	);
}
123